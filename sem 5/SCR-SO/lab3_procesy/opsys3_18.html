<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SCR Systemy Operacyjne - zadanie na pracownie</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Refresh" content="3600">
<script type="text/javascript" src="http://ff.kis.v2.scr.kaspersky-labs.com/1C15FB7F-4483-384F-882D-5D87625C668F/main.js" charset="UTF-8"></script></head>
<body>

<!--  -*- mode: TeX; fill-column: 75; coding: iso-8859-2-unix -*- -->
<p/>

<p/>

<ol>
<p/>

<li> (2p.)
Zapoznaj siê z programem <tt>ps</tt> (<tt>man ps</tt>).  Wypróbuj dwa formaty
wy¶wietlania rozszerzonych infomracji: <tt>-f</tt> i <tt>-l</tt>.  Przeczytaj
podrêcznik polecenia <tt>ps</tt> aby zrozumieæ wy¶wietlane parametry.  Naucz
siê wybieraæ zestaw procesów do wy¶wietlania argumentami opcjonalnymi
<tt>-u</tt>, <tt>-t</tt>, i <tt>-p</tt>.
<p/>

Ile Twoich procesów istnia³o w systemie w chwili przyk³adowego wywo³ania
<tt>ps</tt>?
<p/>

Ile procesów <tt>sshd</tt> istnia³o w systemie (serwerze) w chwili
wykonywania æwiczenia (sprawd¼ polecenie <tt>pgrep</tt>)?
<p/>

<!-- <li> (2p.) -->
<!-- Zapoznaj siê z programem <tt>vmstat</tt> (<tt>man vmstat</tt>) -->
<!-- uruchamiaj±c go na przyk³ad z argumentem 1 zarówno na systemie Solaris -->
<!-- jak i na Linuksie.  Postaraj siê zrozumieæ parametry systemowe -->
<!-- wypisywane przez program.  Sformu³uj kilka prostych wniosków z -->
<!-- porównania zaobserwowanych parametrów systemów diablo i panamint. -->
<p/>

<li> (2p.)
W jednym okienku terminala uruchom hierarchiê co najmniej trzech procesów,
tzn. procesy <tt>A</tt>, który uruchomi proces potomny <tt>B</tt>, który
uruchomi proces potomny <tt>C</tt>.  Mog± to byæ kolejno uruchamiane
interpretery poleceñ, albo uruchamiaj±ce siê kolejno skrypty lub programy.
W innym oknie terminala sprawd¼ programem <tt>ps</tt> zale¿no¶ci potomków i
rodziców w utworzonej hierarchii.
<p/>

Poleceniem <tt>kill</tt> zabij proces w ¶rodku tej hierarchii (<tt>B</tt>).
Sprawd¼ poleceniem <tt>ps</tt> co pozosta³o z pierwotnych procesów, i czy
osierocony proces zostanie poprawnie adoptowany przez proces <tt>init</tt>.
<p/>

W sprawozdaniu z wykonania zadania opisz tylko otrzymany wynik, nie wklejaj
napisanych skryptów.
<p/>

<!-- <li> (2p.) -->
<!-- Obmy¶l jak wyprodukowaæ proces zombie, wykonaj to, i sprawd¼ w jaki -->
<!-- sposób pojawia siê on na li¶cie procesów ps (Linux, Solaris). -->
<!-- Nastêpnie, z pewnym opó¼nieniem spowoduj uwolnienie procesu zombie za -->
<!-- pomoc± wbudowanego polecenia <tt>wait</tt>, nie koñcz±c jeszcze procesu -->
<!-- rodzica.  Sprawd¼, ¿e proces zombie zakoñczy³ siê (znikn±³). -->
<!--  -->
<!-- Wskazówka: interpreter poleceñ <tt>bash</tt> zapobiega powstawaniu zombie -->
<!-- (gdy proces zombie jest uruchomionym przez <tt>bash</tt> skryptem). -->
<!-- Je¶li nie uda Ci siê go zwalczyæ, to mo¿esz zamiast skryptem shella -->
<!-- utworzyæ zombie programem napisanym w C zgodnie z definicj± procesu zombie. -->
<!-- Jest to proste i dzia³a niezawodnie. -->
<!--  -->
<!-- Do sprawozdania z wykonanego zadania do³±cz opracowane skrypty lub program. -->
<p/>

<li> (2p.)
Uruchom potok co najmniej trzech poleceñ dzia³aj±cych przez jaki¶
zauwa¿alny czas.  Mog± to byæ odpowiednio dobrane polecenia systemowe, lub
samodzielnie napisane skrypty.  Sprawd¼ poleceniem <tt>ps</tt> i odpowiedz
jakie zachodzi pokrewieñstwo miêdzy tymi procesami (je¶li w ogóle
zachodzi).
<p/>

Wskazówka: poniewa¿ potok s³u¿y do przesy³ania danych od procesu do
procesu, i synchronizuje pracê wszystkich procesów odpowiednio do
pojawiaj±cych siê danych, dobr± metod± generowania demonstracyjnego potoku
jest umieszczenie na jego pocz±tku procesu, wysy³aj±cego na swoje wyj¶cie
sta³y strumieñ danych, np. pisz±cego w pêtli co sekundê jaki¶ krótki
komunikat.  Kolejne elementy potoku mog± byæ relizowane przez program
<tt>cat</tt>.
<p/>

<li> (2p.)
Poleceniem <tt>mknod</tt> utwórz potok nazwany (FIFO).  W co najmniej
czterech okienkach wywo³aj równoczesne pisanie do, i równoczesne czytanie z
tego potoku przez wiele procesów (polecenie <tt>cat</tt>).
<p/>

Sprawd¼ (i podaj w raporcie) jak system rozdziela dane z pliku procesom o
wspó³dzielonym dostêpie do tego potoku?
<p/>

Zabijaj±c na przemian procesy pisz±ce/czytaj±ce, zaobserwuj, kiedy proces
<tt>cat</tt> czytaj±cy z potoku czeka na wiêcej danych, a kiedy koñczy pracê.
Analogicznie, kiedy proces pisz±cy czeka w gotowo¶ci do dalszego pisania na
potoku, a kiedy samoistnie koñczy pracê.  Podsumuj w raporcie.
<p/>

<!-- <li> -->
<!-- Uruchom kilka podprocesów jednego procesu i wy¶wietlaj±cych -->
<!-- komunikaty na ekranie bez ¿adnego porz±dku ani ³adu.  Celem jest -->
<!-- otrzymanie chaosu na ekranie. -->
<p/>

<li> (2p.)
Napisz skrypt, który w pêtli bêdzie co¶ robi³ (np. co sekundê wypisywa³
bie¿±c± godzinê).  Sprawd¼ wysy³anie do procesu ró¿nych sygna³ów poleceniem
<tt>kill</tt> (<tt>SIGINT</tt>, <tt>SIGQUIT</tt>, ale tak¿e <tt>SIGFPE</tt>,
<tt>SIGILL</tt>).  Nastêpnie rozbuduj skrypt o przechwytywanie tych sygna³ów
(<tt>trap</tt>) i sprawd¼, ¿e to dzia³a, to znaczy, ¿e tak napisanego procesu
nie da siê zabiæ tymi sygna³ami.  Sprawd¼ mo¿liwo¶æ u¶miercenia sygna³em
<tt>SIGKILL</tt> procesu, który przechwytuje wszystkie 15 podstawowych
sygna³ów.
<p/>

Uwaga: trap jest wbudowanym poleceniem shella, i jego wywo³anie trochê
siê ró¿ni pod ró¿nymi shellami.  Naj³atwiej jest wykonaæ to æwiczenie
przy u¿yciu Bourne shella (/bin/sh), poniewa¿ bash wykonuje ró¿ne potajemne
zabiegi z obs³ug± sygna³ów.  Jednak polecenie trap w Bourne shellu jest
prymitywne - czytaj 'man sh'.
<p/>

<li> (2p.)
Sprawd¼ mo¿liwo¶æ zawieszania procesu sygna³em <tt>SIGSTOP</tt> i
wznawiania sygna³em <tt>SIGCONT</tt>.  Sprawd¼, ¿e sygna³ <tt>SIGSTOP</tt>
daje taki sam efekt jak naci¶niêcie klawisza <tt>Ctrl+Z</tt> na
terminalu.  Sprawd¼, ¿e sygna³ <tt>SIGCONT</tt> daje taki sam efekt jak
wykonanie polecenia <tt>fg</tt> lub <tt>bg</tt> (którego bardziej?).
<p/>

<li> (2p.)
Zapoznaj siê z poleceniem <tt>ulimit</tt>.  Ustaw liczbê procesów na ma³±
warto¶æ i sprawd¼, czy dzia³anie jest respektowane.  Nastêpnie napisz
skrypt, który w nieskoñczonej pêtli uruchamia kolejne kopie samego siebie w
tle.  \textbf{Uruchom skrypt koniecznie w tej pow³oce, w której
  ograniczy³e¶/ograniczy³a¶ maksymaln± liczbê procesów!}  Nastêpnie spróbuj
opanowaæ sytuacjê, czyli pozabijaæ wszystkie utworzone procesy i powróciæ
do normalnej pracy.
<p/>

<li> (2p.)
Sprawd¼ warto¶ci priorytetów procesów i ich liczby <tt>nice</tt>, a
nastêpnie przeæwicz obni¿anie priorytetu pracuj±cego w tle procesu
(<tt>nice</tt>/<tt>renice</tt>).  Czy potrafisz zademonstrowaæ dzia³anie
obni¿onego liczb± <tt>nice</tt> priorytetu?
<p/>

Podsumuj wynik w raporcie i podaj polecenie obni¿ania priorytetu procesu.
<p/>

</ol>
<p/>

</body>
</html>
